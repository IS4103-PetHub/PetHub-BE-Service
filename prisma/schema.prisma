//ðŸ§©Don't Edit this file.âœ¨Generated in Wed Sep 27 2023 01:16:23 GMT+0800 (Singapore Standard Time)âœ¨

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// enums
enum AccountStatus {
  ACTIVE
  INACTIVE
  PENDING
}

enum AccountType {
  PET_OWNER
  PET_BUSINESS
  INTERNAL_USER
}

enum AdminRole {
  MANAGER
  ADMINISTRATOR
}

enum BusinessType {
  FNB
  SERVICE
  HEALTHCARE
}

enum BusinessApplicationStatus {
  PENDING
  REJECTED // This means require changes, but is named `REJECTED` in all of our external documentation
  APPROVED
}

enum Gender {
  MALE
  FEMALE
}

enum PetType {
  DOG
  CAT
  BIRD
  TERRAPIN
  RABBIT
  RODENT
  OTHERS
}

enum Category {
  PET_GROOMING
  DINING
  VETERINARY
  PET_RETAIL
  PET_BOARDING
}

model ServiceListing {
  serviceListingId Int       @id @default(autoincrement())
  title            String
  description      String
  basePrice        Float     @default(0)
  attachmentKeys   String[]
  attachmentURLs   String[]
  dateCreated      DateTime  @default(now())
  lastUpdated      DateTime?

  category Category

  // tags that a service listing has (implicit many-to-many relationship)
  tags          Tag[]
  addresses     Address[]
  petBusiness   PetBusiness @relation(fields: [petBusinessId], references: [userId], onDelete: Cascade, onUpdate: Cascade)
  petBusinessId Int
}

// m-n relation type between Tag and ServiceListing: implicit
// https://www.prisma.io/docs/concepts/components/prisma-schema/relations/many-to-many-relations#implicit-many-to-many-relations
model Tag {
  tagId       Int       @id @default(autoincrement())
  name        String    @unique
  dateCreated DateTime  @default(now())
  lastUpdated DateTime?

  // service listings with this tag (implicit many-to-many relationship)
  serviceListings ServiceListing[]
}

// models for Role Based Access Control (RBAC)
// UserGroup: Represents user groups in your system.
// Permission: Represents the permissions that can be granted to user groups.
// UserGroupMembership: Links a User to a UserGroup. Represents the many-to-many relationship between Users and UserGroups.
// UserGroupPermission: Links a UserGroup to a Permission. Represents the many-to-many relationship between UserGroups and Permissions.

model UserGroup {
  groupId              Int                   @id @default(autoincrement())
  name                 String                @unique
  description          String?
  userGroupMemberships UserGroupMembership[]
  userGroupPermissions UserGroupPermission[]
}

model Permission {
  permissionId        Int                   @id @default(autoincrement())
  code                String                @unique
  name                String
  description         String
  UserGroupPermission UserGroupPermission[]
}

model UserGroupMembership {
  user      User      @relation(fields: [userId], references: [userId], onDelete: Cascade)
  userGroup UserGroup @relation(fields: [groupId], references: [groupId], onDelete: Cascade)
  userId    Int
  groupId   Int

  @@id([userId, groupId])
}

model UserGroupPermission {
  userGroup    UserGroup  @relation(fields: [groupId], references: [groupId], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [permissionId], onDelete: Cascade)
  groupId      Int
  permissionId Int

  @@id([groupId, permissionId])
}

// Entities
model User {
  userId        Int           @id @default(autoincrement())
  email         String        @unique
  password      String
  accountType   AccountType
  accountStatus AccountStatus @default(ACTIVE)
  dateCreated   DateTime      @default(now())
  lastUpdated   DateTime?

  // Enforcement of email being associated only with one type of account
  // must be implemented in your application logic as Prisma does not
  // support multi-table unique constraints
  internalUser        InternalUser?
  petOwner            PetOwner?
  petBusiness         PetBusiness?
  UserGroupMembership UserGroupMembership[]
}

model InternalUser {
  firstName                       String
  lastName                        String
  adminRole                       AdminRole
  approvedPetBusinessApplications PetBusinessApplication[]

  user   User @relation(fields: [userId], references: [userId], onDelete: Cascade)
  userId Int  @id @unique
}

model PetOwner {
  firstName     String
  lastName      String
  contactNumber String
  dateOfBirth   DateTime

  user   User @relation(fields: [userId], references: [userId], onDelete: Cascade)
  userId Int  @id @unique

  pets Pet[]
}

model PetBusiness {
  companyName            String
  uen                    String
  contactNumber          String
  // This section is for the optional fields that are empty during PB signup, but populated during PB app approval //
  businessType           BusinessType?
  businessEmail          String?
  businessDescription    String?
  websiteURL             String?
  businessAddresses      Address[]
  // ------------------------------------------------ Section End ------------------------------------------------ //
  serviceListings        ServiceListing[]
  petBusinessApplication PetBusinessApplication?
  // logo                String // TODO: figure out best way to save logos

  user   User @relation(fields: [userId], references: [userId], onDelete: Cascade)
  userId Int  @id @unique
}

model ResetPassword {
  token      String   @unique
  expiryDate DateTime
  email      String
}

model Address {
  addressId                Int                     @id @default(autoincrement())
  addressName              String
  line1                    String
  line2                    String?
  postalCode               String
  // Prisma doesn't seem to support uni-directional relationships: https://github.com/prisma/prisma/issues/3045
  petBusinessId            Int?
  PetBusiness              PetBusiness?            @relation(fields: [petBusinessId], references: [userId], onDelete: Cascade)
  petBusinessApplicationId Int?
  PetBusinessApplication   PetBusinessApplication? @relation(fields: [petBusinessApplicationId], references: [petBusinessApplicationId])

  serviceListings ServiceListing[]
}

model PetBusinessApplication {
  petBusinessApplicationId Int                       @id @default(autoincrement())
  businessType             BusinessType
  businessEmail            String
  businessDescription      String
  businessAddresses        Address[]
  websiteURL               String?
  attachments              String[] // Assuming that these would be URLs pointing to the S3 bucket                 
  applicationStatus        BusinessApplicationStatus @default(PENDING)
  adminRemarks             String[]
  dateCreated              DateTime                  @default(now())
  lastUpdated              DateTime?

  petBusinessId Int         @unique
  petBusiness   PetBusiness @relation(fields: [petBusinessId], references: [userId], onUpdate: Cascade)

  approverId Int?
  approver   InternalUser? @relation(fields: [approverId], references: [userId])
}

model Pet {
  petId           Int       @id @default(autoincrement())
  petName         String
  petType         PetType
  gender          Gender
  dateOfBirth     DateTime?
  petWeight       Float?
  microchipNumber String?
  attachmentKeys  String[]
  attachmentURLs  String[]
  dateCreated     DateTime  @default(now())
  lastUpdated     DateTime?

  petOwnerId Int
  petOwner   PetOwner @relation(fields: [petOwnerId], references: [userId], onDelete: Cascade, onUpdate: Cascade)
}
