//ðŸ§©Don't Edit this file.âœ¨Generated in Mon Oct 02 2023 01:02:30 GMT+0800 (GMT+08:00)âœ¨

model CalendarGroup {
  calendarGroupId  Int                @id @default(autoincrement())
  name             String
  description      String?
  timeslots        TimeSlot[]
  scheduleSettings ScheduleSettings[]

  petBusinessId  Int // CalendarGroup ISA Weak Entity of PetBusiness 
  petBusiness    PetBusiness      @relation(fields: [petBusinessId], references: [userId], onDelete: Cascade)
  ServiceListing ServiceListing[]

  @@unique([petBusinessId, name])
}

model ScheduleSettings {
  scheduleSettingId Int               @id @default(autoincrement())
  days              DayOfWeek[]
  pattern           RecurrencePattern
  startDate         String // Only require Date portion
  endDate           String // Only require Date portion
  timePeriods       TimePeriod[]

  calendarGroupId Int // ScheduleSettings ISA Weak Entity of CalendarGroup 
  CalendarGroup   CalendarGroup @relation(fields: [calendarGroupId], references: [calendarGroupId], onDelete: Cascade)
}

model TimePeriod {
  timePeriodId Int    @id @default(autoincrement())
  startTime    String
  endTime      String
  vacancies    Int

  scheduleSettingId Int // TimePeriods ISA Weak Entity of ScheduleSettings 
  ScheduleSettings  ScheduleSettings @relation(fields: [scheduleSettingId], references: [scheduleSettingId], onDelete: Cascade)
}

model TimeSlot {
  timeSlotId Int      @id @default(autoincrement())
  startTime  DateTime
  endTime    DateTime
  vacancies  Int

  calendarGroupId Int
  CalendarGroup   CalendarGroup @relation(fields: [calendarGroupId], references: [calendarGroupId], onDelete: Cascade)

  Booking Booking[]
}

model Booking {
  bookingId     Int       @id @default(autoincrement())
  invoiceId     Int?
  transactionId Int?
  petOwnerId    Int
  dateCreated   DateTime  @default(now())
  lastUpdated   DateTime?

  startTime DateTime
  endTime   DateTime

  serviceListingId Int
  serviceListing   ServiceListing @relation(fields: [serviceListingId], references: [serviceListingId], onDelete: Cascade)

  timeSlotId Int?
  timeSlot   TimeSlot? @relation(fields: [timeSlotId], references: [timeSlotId], onUpdate: Cascade, onDelete: SetNull)

  petId Int?
  pet   Pet? @relation(fields: [petId], references: [petId], onUpdate: Cascade, onDelete: Cascade)
}

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// enums
enum AccountStatus {
  ACTIVE
  INACTIVE
  PENDING
}

enum AccountType {
  PET_OWNER
  PET_BUSINESS
  INTERNAL_USER
}

enum AdminRole {
  MANAGER
  ADMINISTRATOR
}

enum BusinessType {
  FNB
  SERVICE
  HEALTHCARE
}

enum BusinessApplicationStatus {
  PENDING
  REJECTED // This means require changes, but is named `REJECTED` in all of our external documentation
  APPROVED
}

enum Gender {
  MALE
  FEMALE
}

enum PetType {
  DOG
  CAT
  BIRD
  TERRAPIN
  RABBIT
  RODENT
  OTHERS
}

enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

enum RecurrencePattern {
  DAILY
  WEEKLY
}

enum Category {
  PET_GROOMING
  DINING
  VETERINARY
  PET_RETAIL
  PET_BOARDING
}

model ServiceListing {
  serviceListingId Int       @id @default(autoincrement())
  title            String
  description      String
  basePrice        Float     @default(0)
  attachmentKeys   String[]
  attachmentURLs   String[]
  dateCreated      DateTime  @default(now())
  lastUpdated      DateTime?
  duration         Int?

  category Category

  // tags that a service listing has (implicit many-to-many relationship)
  tags            Tag[]
  addresses       Address[]
  petBusiness     PetBusiness @relation(fields: [petBusinessId], references: [userId], onDelete: Cascade, onUpdate: Cascade)
  petBusinessId   Int
  favouritedUsers PetOwner[]

  calendarGroupId Int?
  CalendarGroup   CalendarGroup? @relation(fields: [calendarGroupId], references: [calendarGroupId], onDelete: Cascade, onUpdate: Cascade)
  Booking         Booking[]
}

// m-n relation type between Tag and ServiceListing: implicit
// https://www.prisma.io/docs/concepts/components/prisma-schema/relations/many-to-many-relations#implicit-many-to-many-relations
model Tag {
  tagId       Int       @id @default(autoincrement())
  name        String    @unique
  dateCreated DateTime  @default(now())
  lastUpdated DateTime?

  // service listings with this tag (implicit many-to-many relationship)
  serviceListings ServiceListing[]
}

// models for Role Based Access Control (RBAC)
// UserGroup: Represents user groups in your system.
// Permission: Represents the permissions that can be granted to user groups.
// UserGroupMembership: Links a User to a UserGroup. Represents the many-to-many relationship between Users and UserGroups.
// UserGroupPermission: Links a UserGroup to a Permission. Represents the many-to-many relationship between UserGroups and Permissions.

model UserGroup {
  groupId              Int                   @id @default(autoincrement())
  name                 String                @unique
  description          String?
  userGroupMemberships UserGroupMembership[]
  userGroupPermissions UserGroupPermission[]
}

model Permission {
  permissionId        Int                   @id @default(autoincrement())
  code                String                @unique
  name                String
  description         String
  UserGroupPermission UserGroupPermission[]
}

model UserGroupMembership {
  user      User      @relation(fields: [userId], references: [userId], onDelete: Cascade)
  userGroup UserGroup @relation(fields: [groupId], references: [groupId], onDelete: Cascade)
  userId    Int
  groupId   Int

  @@id([userId, groupId])
}

model UserGroupPermission {
  userGroup    UserGroup  @relation(fields: [groupId], references: [groupId], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [permissionId], onDelete: Cascade)
  groupId      Int
  permissionId Int

  @@id([groupId, permissionId])
}

// Entities
model User {
  userId        Int           @id @default(autoincrement())
  email         String        @unique
  password      String
  accountType   AccountType
  accountStatus AccountStatus @default(ACTIVE)
  dateCreated   DateTime      @default(now())
  lastUpdated   DateTime?

  // Enforcement of email being associated only with one type of account
  // must be implemented in your application logic as Prisma does not
  // support multi-table unique constraints
  internalUser        InternalUser?
  petOwner            PetOwner?
  petBusiness         PetBusiness?
  UserGroupMembership UserGroupMembership[]
}

model InternalUser {
  firstName                       String
  lastName                        String
  adminRole                       AdminRole
  approvedPetBusinessApplications PetBusinessApplication[]

  user   User @relation(fields: [userId], references: [userId], onDelete: Cascade)
  userId Int  @id @unique
}

model PetOwner {
  firstName     String
  lastName      String
  contactNumber String
  dateOfBirth   DateTime

  user   User @relation(fields: [userId], references: [userId], onDelete: Cascade)
  userId Int  @id @unique

  pets              Pet[]
  favouriteListings ServiceListing[]
}

model PetBusiness {
  companyName            String
  uen                    String
  contactNumber          String
  // This section is for the optional fields that are empty during PB signup, but populated during PB app approval //
  businessType           BusinessType?
  businessEmail          String?
  businessDescription    String?
  websiteURL             String?
  businessAddresses      Address[]
  // ------------------------------------------------ Section End ------------------------------------------------ //
  serviceListings        ServiceListing[]
  petBusinessApplication PetBusinessApplication?
  // logo                String // TODO: figure out best way to save logos

  user          User            @relation(fields: [userId], references: [userId], onDelete: Cascade)
  userId        Int             @id @unique
  CalendarGroup CalendarGroup[]
}

model ResetPassword {
  token      String   @unique
  expiryDate DateTime
  email      String
}

model Address {
  addressId                Int                     @id @default(autoincrement())
  addressName              String
  line1                    String
  line2                    String?
  postalCode               String
  // Prisma doesn't seem to support uni-directional relationships: https://github.com/prisma/prisma/issues/3045
  petBusinessId            Int?
  PetBusiness              PetBusiness?            @relation(fields: [petBusinessId], references: [userId], onDelete: Cascade)
  petBusinessApplicationId Int?
  PetBusinessApplication   PetBusinessApplication? @relation(fields: [petBusinessApplicationId], references: [petBusinessApplicationId])

  serviceListings ServiceListing[]
}

model Pet {
  petId           Int       @id @default(autoincrement())
  petName         String
  petType         PetType
  gender          Gender
  dateOfBirth     DateTime?
  petWeight       Float?
  microchipNumber String?
  attachmentKeys  String[]
  attachmentURLs  String[]
  dateCreated     DateTime  @default(now())
  lastUpdated     DateTime?

  petOwnerId Int
  petOwner   PetOwner @relation(fields: [petOwnerId], references: [userId], onDelete: Cascade, onUpdate: Cascade)

  bookings Booking[]
}

model PetBusinessApplication {
  petBusinessApplicationId Int                       @id @default(autoincrement())
  businessType             BusinessType
  businessEmail            String
  businessDescription      String
  businessAddresses        Address[]
  websiteURL               String?
  attachments              String[] // Assuming that these would be URLs pointing to the S3 bucket                 
  applicationStatus        BusinessApplicationStatus @default(PENDING)
  adminRemarks             String[]
  dateCreated              DateTime                  @default(now())
  lastUpdated              DateTime?

  petBusinessId Int         @unique
  petBusiness   PetBusiness @relation(fields: [petBusinessId], references: [userId], onUpdate: Cascade)

  approverId Int?
  approver   InternalUser? @relation(fields: [approverId], references: [userId])
}
